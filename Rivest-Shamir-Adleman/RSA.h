#ifndef RSA_H_INCLUDED
#define RSA_H_INCLUDED

#include <iostream>
#include <vector>
#include <ctime>

using namespace std;

class RSA {
    private:
        int p;
        int q;
        int n;
        vector<int> reducedSetOfResidues;
        int e = 2; // 1 <  e <  phi(n)
        int d = 0; // 0 <= d <= n
        int m;
        int c;

        int RSA_Encryption(int);
        int RSA_Decryption(int);
        bool isPrime(int );
        int gcd(int, int);
        void findReducedSetOfResidues(int);
        int findE(int);
        int findD(int, int);
        void generateKeys(); // Generate Public and Private Keys
        int modularExponentiation(int, unsigned int, int); // Computes The Modular Exponentiation (pow(base, exponent) % modulusValue)

    public:
        RSA();
};

RSA::RSA() {
    generateKeys();

    do {
        cout << endl << "> Enter Message to Encrypt (Message Must be Less Than n = " << n << "): ";
        cin >> m;
    } while (m >= n);

    c = RSA_Encryption(m);
    cout << endl << "> Encrypted Message (c): " << c << endl;

    m = RSA_Decryption(c);
    cout << "> Decrypted Message (m): " << m << endl;
}

int RSA::RSA_Encryption(int m) {
    // c = pow(m, e) % n
    return modularExponentiation(m, e, n);
}

int RSA::RSA_Decryption(int c) {
    // m = pow(c, d) % n
    return modularExponentiation(c, d, n);
}


bool RSA::isPrime(int n) {
    // Check if n is less than or equal to 1, which is not prime
    if (n <= 1) {
        return false;
    }
    // Check if n is 2 or 3, both of which are prime
    if ((n == 2) || (n == 3)) {
        return true;
    }
    // If n is divisible by 2 or 3, excluding 2 and 3 themselves, it's not prime
    if (n % 2 == 0 || n % 3 == 0) {
        return false;
    }

    for (int i = 5; i * i <= n; i += 6){
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    return true;
}

int RSA::gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}

void RSA::findReducedSetOfResidues(int phi) {
    while (e < phi) {
        // gcd(e, phi(n)) = 1
        if (gcd(e, phi) == 1) {
            reducedSetOfResidues.push_back(e);
        }
        e++;
    }

    // Print Reduced Set Of Residues
    cout << "> Reduced Set Of Residues: { ";
    for (int i = 0; i < reducedSetOfResidues.size(); ++i) {
        cout << reducedSetOfResidues[i] << " ";
    }
    cout << "}";
}

int RSA::findE(int phi) {
    // Seed The Random Number Generator With The Current Time To Ensure That The Sequence of Random Numbers Generated by
    // rand() Varies Each Time We Run The Program. Thus, RandomIndex Will Be Different Each T  ime.
    srand(time(0));

    // Find Reduced Set Of Residues
    findReducedSetOfResidues(phi);

    // Generate a Random Index
    int reducedSetOfResiduesLengthMinusOne = reducedSetOfResidues.size() - 1;

    // Randomly Generate Random Index in The Range [1, reducedSetOfResiduesLengthMinusOne]
    int randomIndex = rand() % reducedSetOfResiduesLengthMinusOne;

    if (!reducedSetOfResidues.empty()) {
        e = reducedSetOfResidues[randomIndex];
        return e;
    } else {
        return -1; // Return -1 if no suitable 'e' is found
    }
}

int RSA::findD(int e, int phi) {
    int d = 0;
    int k = 1;
    while ((1 + (k * phi  )) % e != 0) {
        k++;
    }
    d = (1 + (k * phi)) / e;
    return d;
}

void RSA::generateKeys() {
    do {
        cout << "> Enter The First Prime Number  (p): ";
        cin >> p;
    } while (!isPrime(p));

    do {
        cout << "> Enter The Second Prime Number (q): ";
        cin >> q;
    } while (!isPrime(q));

    cout << endl;

    // n = p * q
    n = p * q;
    cout << "n      = " << "   p    " << "*" << "    q   " << " = " << p << " * " << q << " = " << n << endl;

    // phi(n) = p - 1) * (q - 1)
    int phi = (p - 1) * (q - 1);
    cout << "phi(n) = " << "(p - 1)" << " * " << "(q - 1)" << " = " << (p - 1) << " * " << (q - 1) << " = " << phi << endl;

    e = findE(phi);
    if (e == -1) {
        cout << endl << endl << "=> Error: Unable to Find 'e'. This Might Occur If The Prime Numbers Chosen Are:" << endl;
        cout << "- Too Small or" << endl;
        cout << "- Not Relatively Prime With (p-1)*(q-1)." << endl;
        cout << "> Please Choose Different Prime Numbers, Ensuring They are Larger and Mutually Prime With (p-1)*(q-1)." << endl << endl;
        RSA();
    }
    cout << " , " << "e = " << e << " , ";

    d = findD(e, phi);
    cout << "d = " << d << endl << endl;

    cout << "Public  Key: " << "{ " <<  e << ", " << n << " }" << endl;
    cout << "Private Key: " << "{ " <<  d << ", " << n << " }" << endl;
}

int RSA::modularExponentiation(int base, unsigned int exponent, int modulusValue) {
    int result = 1;
    base = base % modulusValue;

    while (exponent > 0) {
        if (exponent % 2 == 1){
            result = (result * base) % modulusValue;
        }
        //
        exponent = exponent / 2;
        //
        base = (base * base) % modulusValue;
    }

    return result;
}
#endif
